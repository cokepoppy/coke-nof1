# NOF1.AI 系统设计方案

## 1. 系统架构设计

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                         用户层                                │
│  ┌─────────────┐  ┌──────────────┐  ┌─────────────┐        │
│  │  Web Browser │  │ Mobile Browser│  │  Admin Panel│        │
│  └─────────────┘  └──────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
                            │
                    ┌───────┴───────┐
                    │   Nginx       │
                    │ (Reverse Proxy)│
                    └───────┬───────┘
                            │
┌─────────────────────────────────────────────────────────────┐
│                      应用层（Node.js）                        │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              Express.js API Server                   │   │
│  │  ┌────────────┐  ┌─────────────┐  ┌──────────────┐  │   │
│  │  │ Auth Module│  │ User Module │  │ Model Module │  │   │
│  │  └────────────┘  └─────────────┘  └──────────────┘  │   │
│  │  ┌────────────┐  ┌─────────────┐  ┌──────────────┐  │   │
│  │  │Trade Module│  │ Market Data │  │ Analytics    │  │   │
│  │  └────────────┘  └─────────────┘  └──────────────┘  │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              WebSocket Server (Socket.IO)            │   │
│  │  - Real-time Price Updates                           │   │
│  │  - Live Trading Signals                              │   │
│  │  - Position Updates                                  │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              Trading Engine Service                  │   │
│  │  ┌────────────┐  ┌─────────────┐  ┌──────────────┐  │   │
│  │  │AI Orchestr.│  │Risk Manager │  │Order Executor│  │   │
│  │  └────────────┘  └─────────────┘  └──────────────┘  │   │
│  │  ┌────────────┐  ┌─────────────┐                    │   │
│  │  │LLM Integr. │  │Indicator Calc│                   │   │
│  │  └────────────┘  └─────────────┘                    │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │           Task Scheduler (node-cron)                 │   │
│  │  - Market Data Fetching (every 10s)                  │   │
│  │  - AI Decision Loop (every 2-3 min)                  │   │
│  │  - Performance Calculation (every 5 min)             │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────┴────────┐  ┌───────┴────────┐  ┌──────┴──────┐
│  MySQL         │  │  Redis         │  │ External APIs│
│  - Users       │  │  - Session     │  │ - Hyperliquid│
│  - Models      │  │  - Cache       │  │ - OpenAI     │
│  - Trades      │  │  - Real-time   │  │ - Anthropic  │
│  - Positions   │  │    Data        │  │ - Google AI  │
│  - Market Data │  └────────────────┘  │ - DeepSeek   │
│  - Logs        │                      │ - etc.       │
└────────────────┘                      └──────────────┘
```

### 1.2 前端架构

```
src/
├── assets/              # 静态资源（图片、图标）
├── components/          # 可复用组件
│   ├── common/         # 通用组件
│   │   ├── Navbar.tsx
│   │   ├── Footer.tsx
│   │   ├── LoadingSpinner.tsx
│   │   └── ErrorBoundary.tsx
│   ├── charts/         # 图表组件
│   │   ├── PriceChart.tsx
│   │   ├── PerformanceChart.tsx
│   │   └── TradingViewChart.tsx
│   ├── trading/        # 交易相关组件
│   │   ├── PriceCard.tsx
│   │   ├── PositionList.tsx
│   │   ├── TradeHistory.tsx
│   │   └── DecisionLog.tsx
│   └── leaderboard/    # 排行榜组件
│       ├── ModelRanking.tsx
│       └── MetricsTable.tsx
├── pages/              # 页面组件
│   ├── Home.tsx
│   ├── Live.tsx
│   ├── Leaderboard.tsx
│   ├── ModelDetail.tsx
│   ├── Blog.tsx
│   ├── BlogPost.tsx
│   └── About.tsx
├── hooks/              # 自定义 Hooks
│   ├── useWebSocket.ts
│   ├── useMarketData.ts
│   ├── useAuth.ts
│   └── usePolling.ts
├── store/              # 状态管理
│   ├── index.ts
│   ├── slices/
│   │   ├── authSlice.ts
│   │   ├── marketSlice.ts
│   │   ├── tradingSlice.ts
│   │   └── uiSlice.ts
│   └── api/            # RTK Query API
│       ├── authApi.ts
│       ├── tradingApi.ts
│       └── marketApi.ts
├── services/           # API 服务
│   ├── api.ts         # Axios 配置
│   ├── websocket.ts   # WebSocket 客户端
│   └── auth.ts        # 认证服务
├── types/              # TypeScript 类型定义
│   ├── models.ts
│   ├── trading.ts
│   ├── market.ts
│   └── api.ts
├── utils/              # 工具函数
│   ├── formatters.ts  # 格式化函数
│   ├── validators.ts  # 验证函数
│   └── constants.ts   # 常量
├── styles/             # 样式文件
│   ├── globals.css
│   └── themes/
├── App.tsx
└── main.tsx
```

### 1.3 后端架构

```
src/
├── config/                  # 配置文件
│   ├── database.ts         # 数据库配置
│   ├── redis.ts            # Redis 配置
│   ├── llm.ts              # LLM API 配置
│   └── exchange.ts         # 交易所配置
├── controllers/            # 控制器
│   ├── authController.ts
│   ├── userController.ts
│   ├── modelController.ts
│   ├── tradeController.ts
│   ├── marketController.ts
│   └── blogController.ts
├── services/               # 业务逻辑服务
│   ├── authService.ts
│   ├── tradingEngine/     # 交易引擎
│   │   ├── index.ts
│   │   ├── aiOrchestrator.ts    # AI 编排
│   │   ├── llmIntegration.ts    # LLM 集成
│   │   ├── riskManager.ts       # 风险管理
│   │   ├── orderExecutor.ts     # 订单执行
│   │   └── indicatorCalc.ts     # 指标计算
│   ├── marketDataService.ts     # 市场数据
│   ├── analyticsService.ts      # 分析服务
│   └── notificationService.ts   # 通知服务
├── models/                 # 数据模型（TypeORM Entities）
│   ├── User.ts
│   ├── AIModel.ts
│   ├── Trade.ts
│   ├── Position.ts
│   ├── MarketData.ts
│   ├── DecisionLog.ts
│   ├── PerformanceMetric.ts
│   └── BlogPost.ts
├── routes/                 # 路由
│   ├── index.ts
│   ├── authRoutes.ts
│   ├── userRoutes.ts
│   ├── modelRoutes.ts
│   ├── tradeRoutes.ts
│   ├── marketRoutes.ts
│   └── blogRoutes.ts
├── middleware/             # 中间件
│   ├── authMiddleware.ts
│   ├── errorHandler.ts
│   ├── rateLimiter.ts
│   └── validator.ts
├── utils/                  # 工具函数
│   ├── logger.ts
│   ├── jwt.ts
│   ├── prompts.ts         # 提示词模板
│   └── calculations.ts    # 数学计算
├── types/                  # TypeScript 类型
│   ├── express.d.ts
│   ├── trading.ts
│   └── llm.ts
├── websocket/              # WebSocket 处理
│   ├── index.ts
│   ├── handlers.ts
│   └── rooms.ts
├── jobs/                   # 定时任务
│   ├── marketDataJob.ts
│   ├── tradingJob.ts
│   └── analyticsJob.ts
├── app.ts                  # Express 应用配置
└── server.ts               # 服务器入口
```

## 2. 数据库设计

### 2.1 ER 图概览

```
┌─────────────┐      ┌──────────────┐      ┌──────────────┐
│    User     │──┬───│   AIModel    │──┬───│    Trade     │
└─────────────┘  │   └──────────────┘  │   └──────────────┘
                 │                     │
                 │   ┌──────────────┐  │   ┌──────────────┐
                 └───│  Position    │  └───│ DecisionLog  │
                     └──────────────┘      └──────────────┘
                            │
                     ┌──────────────┐
                     │ MarketData   │
                     └──────────────┘
                            │
                     ┌──────────────┐      ┌──────────────┐
                     │Performance   │      │  BlogPost    │
                     │   Metric     │      └──────────────┘
                     └──────────────┘
```

### 2.2 详细表结构

#### 2.2.1 users 表
```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    full_name VARCHAR(255),
    role ENUM('admin', 'user', 'viewer') DEFAULT 'viewer',
    status ENUM('active', 'inactive', 'banned') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_login TIMESTAMP NULL,
    INDEX idx_email (email),
    INDEX idx_username (username)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 2.2.2 ai_models 表
```sql
CREATE TABLE ai_models (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,                    -- e.g., 'GPT-5', 'Claude Sonnet 4.5'
    provider VARCHAR(50) NOT NULL,                 -- e.g., 'openai', 'anthropic'
    model_id VARCHAR(100) NOT NULL,                -- e.g., 'gpt-4', 'claude-3-sonnet'
    api_key_encrypted TEXT,                        -- 加密的 API 密钥
    system_prompt TEXT NOT NULL,                   -- 系统提示词
    initial_balance DECIMAL(20, 8) DEFAULT 10000,  -- 初始资金
    current_balance DECIMAL(20, 8),                -- 当前余额
    status ENUM('active', 'paused', 'stopped') DEFAULT 'paused',
    config JSON,                                   -- 额外配置（温度、最大tokens等）
    season INT DEFAULT 1,                          -- 赛季
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_provider (provider),
    INDEX idx_status (status),
    INDEX idx_season (season)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 2.2.3 trades 表
```sql
CREATE TABLE trades (
    id INT PRIMARY KEY AUTO_INCREMENT,
    model_id INT NOT NULL,
    symbol VARCHAR(20) NOT NULL,                   -- e.g., 'BTC', 'ETH'
    side ENUM('LONG', 'SHORT') NOT NULL,
    entry_price DECIMAL(20, 8) NOT NULL,
    exit_price DECIMAL(20, 8),
    quantity DECIMAL(20, 8) NOT NULL,
    leverage INT NOT NULL,
    entry_time TIMESTAMP NOT NULL,
    exit_time TIMESTAMP NULL,
    status ENUM('open', 'closed', 'liquidated') DEFAULT 'open',
    profit_loss DECIMAL(20, 8),                    -- 盈亏（USDT）
    profit_loss_pct DECIMAL(10, 4),                -- 盈亏百分比
    fees DECIMAL(20, 8),                           -- 交易费用
    profit_target DECIMAL(20, 8),                  -- 止盈目标
    stop_loss DECIMAL(20, 8),                      -- 止损价格
    invalidation_condition TEXT,                   -- 失效条件
    confidence DECIMAL(3, 2),                      -- 信心评分 0-1
    entry_reason TEXT,                             -- 入场理由
    exit_reason TEXT,                              -- 出场理由
    exchange_order_id VARCHAR(100),                -- 交易所订单ID
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (model_id) REFERENCES ai_models(id) ON DELETE CASCADE,
    INDEX idx_model_id (model_id),
    INDEX idx_symbol (symbol),
    INDEX idx_status (status),
    INDEX idx_entry_time (entry_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 2.2.4 positions 表
```sql
CREATE TABLE positions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    model_id INT NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    side ENUM('LONG', 'SHORT') NOT NULL,
    entry_price DECIMAL(20, 8) NOT NULL,
    current_price DECIMAL(20, 8) NOT NULL,
    quantity DECIMAL(20, 8) NOT NULL,
    leverage INT NOT NULL,
    unrealized_pnl DECIMAL(20, 8),                 -- 未实现盈亏
    unrealized_pnl_pct DECIMAL(10, 4),
    margin DECIMAL(20, 8),                         -- 保证金
    liquidation_price DECIMAL(20, 8),              -- 爆仓价格
    profit_target DECIMAL(20, 8),
    stop_loss DECIMAL(20, 8),
    invalidation_condition TEXT,
    confidence DECIMAL(3, 2),
    entry_reason TEXT,
    opened_at TIMESTAMP NOT NULL,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (model_id) REFERENCES ai_models(id) ON DELETE CASCADE,
    INDEX idx_model_id (model_id),
    INDEX idx_symbol (symbol),
    UNIQUE KEY unique_model_symbol (model_id, symbol)  -- 每个模型每个币种只能有一个持仓
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 2.2.5 market_data 表
```sql
CREATE TABLE market_data (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    symbol VARCHAR(20) NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    open DECIMAL(20, 8) NOT NULL,
    high DECIMAL(20, 8) NOT NULL,
    low DECIMAL(20, 8) NOT NULL,
    close DECIMAL(20, 8) NOT NULL,
    volume DECIMAL(30, 8) NOT NULL,
    interval_type ENUM('1m', '3m', '5m', '15m', '1h', '4h', '1d') NOT NULL,

    -- 技术指标
    ema_20 DECIMAL(20, 8),
    ema_50 DECIMAL(20, 8),
    rsi DECIMAL(10, 4),
    macd DECIMAL(20, 8),
    macd_signal DECIMAL(20, 8),
    macd_histogram DECIMAL(20, 8),
    atr DECIMAL(20, 8),

    -- 市场指标
    open_interest DECIMAL(30, 8),
    funding_rate DECIMAL(10, 8),

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_symbol_timestamp (symbol, timestamp),
    INDEX idx_symbol_interval (symbol, interval_type),
    UNIQUE KEY unique_data_point (symbol, timestamp, interval_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 2.2.6 decision_logs 表
```sql
CREATE TABLE decision_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    model_id INT NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    decision_type ENUM('LONG', 'SHORT', 'HOLD', 'CLOSE') NOT NULL,
    symbol VARCHAR(20),
    reasoning TEXT NOT NULL,                       -- AI 的推理过程
    market_context JSON,                           -- 决策时的市场数据快照
    account_context JSON,                          -- 决策时的账户状态
    output_json JSON,                              -- AI 输出的完整 JSON
    execution_status ENUM('pending', 'executed', 'failed', 'skipped') DEFAULT 'pending',
    execution_error TEXT,                          -- 执行错误信息
    latency_ms INT,                                -- API 响应延迟
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (model_id) REFERENCES ai_models(id) ON DELETE CASCADE,
    INDEX idx_model_timestamp (model_id, timestamp),
    INDEX idx_decision_type (decision_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 2.2.7 performance_metrics 表
```sql
CREATE TABLE performance_metrics (
    id INT PRIMARY KEY AUTO_INCREMENT,
    model_id INT NOT NULL,
    calculation_time TIMESTAMP NOT NULL,

    -- 基础指标
    total_pnl DECIMAL(20, 8),                      -- 总盈亏
    total_pnl_pct DECIMAL(10, 4),                  -- 总收益率
    realized_pnl DECIMAL(20, 8),                   -- 已实现盈亏
    unrealized_pnl DECIMAL(20, 8),                 -- 未实现盈亏

    -- 交易统计
    total_trades INT DEFAULT 0,
    winning_trades INT DEFAULT 0,
    losing_trades INT DEFAULT 0,
    win_rate DECIMAL(5, 2),                        -- 胜率

    -- 风险指标
    sharpe_ratio DECIMAL(10, 4),                   -- 夏普比率
    max_drawdown DECIMAL(10, 4),                   -- 最大回撤
    max_drawdown_pct DECIMAL(10, 4),
    volatility DECIMAL(10, 4),                     -- 波动率

    -- 其他指标
    avg_trade_duration_minutes INT,                -- 平均持仓时间
    avg_profit_per_trade DECIMAL(20, 8),
    avg_loss_per_trade DECIMAL(20, 8),
    profit_factor DECIMAL(10, 4),                  -- 盈利因子

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (model_id) REFERENCES ai_models(id) ON DELETE CASCADE,
    INDEX idx_model_time (model_id, calculation_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 2.2.8 blog_posts 表
```sql
CREATE TABLE blog_posts (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    slug VARCHAR(255) UNIQUE NOT NULL,
    content TEXT NOT NULL,                         -- Markdown 内容
    excerpt TEXT,                                  -- 摘要
    author_id INT,
    status ENUM('draft', 'published', 'archived') DEFAULT 'draft',
    published_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE SET NULL,
    INDEX idx_slug (slug),
    INDEX idx_status (status),
    INDEX idx_published_at (published_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

#### 2.2.9 waitlist 表
```sql
CREATE TABLE waitlist (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255),
    status ENUM('pending', 'invited', 'registered') DEFAULT 'pending',
    source VARCHAR(100),                           -- 来源渠道
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    invited_at TIMESTAMP NULL,
    INDEX idx_email (email),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

## 3. API 设计

### 3.1 RESTful API 端点

#### 3.1.1 认证 API
```
POST   /api/auth/register         # 注册
POST   /api/auth/login            # 登录
POST   /api/auth/logout           # 登出
POST   /api/auth/refresh          # 刷新 token
GET    /api/auth/me               # 获取当前用户信息
```

#### 3.1.2 用户 API
```
GET    /api/users                 # 获取用户列表（管理员）
GET    /api/users/:id             # 获取用户详情
PUT    /api/users/:id             # 更新用户信息
DELETE /api/users/:id             # 删除用户（管理员）
```

#### 3.1.3 AI 模型 API
```
GET    /api/models                # 获取所有 AI 模型列表
GET    /api/models/:id            # 获取模型详情
POST   /api/models                # 创建新模型（管理员）
PUT    /api/models/:id            # 更新模型配置（管理员）
DELETE /api/models/:id            # 删除模型（管理员）
POST   /api/models/:id/start      # 启动模型交易
POST   /api/models/:id/pause      # 暂停模型交易
POST   /api/models/:id/stop       # 停止模型交易
```

#### 3.1.4 交易 API
```
GET    /api/trades                # 获取所有交易记录
GET    /api/trades/:id            # 获取交易详情
GET    /api/models/:id/trades     # 获取指定模型的交易记录
POST   /api/trades                # 手动创建交易（测试用）
```

#### 3.1.5 持仓 API
```
GET    /api/positions             # 获取所有持仓
GET    /api/positions/:id         # 获取持仓详情
GET    /api/models/:id/positions  # 获取指定模型的持仓
```

#### 3.1.6 市场数据 API
```
GET    /api/market/prices         # 获取实时价格
GET    /api/market/history        # 获取历史数据
        Query: symbol, interval, start, end
GET    /api/market/indicators     # 获取技术指标
        Query: symbol, indicators[]
```

#### 3.1.7 排行榜 API
```
GET    /api/leaderboard           # 获取排行榜
        Query: season, sortBy, order
GET    /api/leaderboard/:modelId  # 获取模型排名详情
```

#### 3.1.8 决策日志 API
```
GET    /api/models/:id/decisions  # 获取模型的决策日志
GET    /api/decisions/:id         # 获取决策详情
```

#### 3.1.9 性能指标 API
```
GET    /api/models/:id/performance  # 获取模型性能指标
        Query: startDate, endDate
GET    /api/analytics/compare       # 对比多个模型
        Query: modelIds[], metrics[]
```

#### 3.1.10 博客 API
```
GET    /api/blog/posts            # 获取博客文章列表
GET    /api/blog/posts/:slug      # 获取文章详情
POST   /api/blog/posts            # 创建文章（管理员）
PUT    /api/blog/posts/:id        # 更新文章（管理员）
DELETE /api/blog/posts/:id        # 删除文章（管理员）
```

#### 3.1.11 等待列表 API
```
POST   /api/waitlist              # 加入等待列表
        Body: { email, name }
GET    /api/waitlist              # 获取等待列表（管理员）
PUT    /api/waitlist/:id/invite   # 邀请用户（管理员）
```

### 3.2 WebSocket 事件

#### 3.2.1 客户端 → 服务器
```
connect                           # 连接
disconnect                        # 断开
subscribe:prices                  # 订阅价格更新
unsubscribe:prices                # 取消订阅
subscribe:model                   # 订阅模型更新
  Data: { modelId }
unsubscribe:model                 # 取消订阅模型
  Data: { modelId }
```

#### 3.2.2 服务器 → 客户端
```
connected                         # 连接成功
price:update                      # 价格更新
  Data: { symbol, price, timestamp }
model:decision                    # 模型决策
  Data: { modelId, decision, timestamp }
model:trade                       # 交易执行
  Data: { modelId, trade }
model:position:update             # 持仓更新
  Data: { modelId, position }
model:balance:update              # 余额更新
  Data: { modelId, balance }
leaderboard:update                # 排行榜更新
  Data: { rankings }
error                             # 错误信息
  Data: { message, code }
```

### 3.3 请求/响应格式

#### 3.3.1 标准成功响应
```json
{
  "success": true,
  "data": { ... },
  "message": "操作成功",
  "timestamp": 1698765432000
}
```

#### 3.3.2 标准错误响应
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "输入验证失败",
    "details": [
      {
        "field": "email",
        "message": "无效的邮箱格式"
      }
    ]
  },
  "timestamp": 1698765432000
}
```

#### 3.3.3 分页响应
```json
{
  "success": true,
  "data": {
    "items": [ ... ],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 156,
      "totalPages": 8
    }
  }
}
```

## 4. 交易引擎设计

### 4.1 AI 决策循环流程

```
┌─────────────────────────────────────────────────────────────┐
│                    Trading Loop (2-3 min)                   │
└─────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 1. 获取市场数据                                              │
│    - 获取所有资产的实时价格                                   │
│    - 计算技术指标（EMA, MACD, RSI, ATR）                     │
│    - 获取持仓量和资金费率                                     │
│    - 构建多时间框架数据（3m + 4h）                            │
└─────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 获取账户状态                                              │
│    - 查询当前余额                                            │
│    - 查询所有持仓                                            │
│    - 计算未实现盈亏                                          │
│    - 查询最近的性能指标（夏普比率）                           │
└─────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 构建提示词                                                │
│    - 加载系统提示词模板                                       │
│    - 插入市场数据（按最旧→最新排序）                          │
│    - 插入账户状态                                            │
│    - 添加风险管理指令                                        │
│    - 指定 JSON 输出格式                                      │
└─────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 调用 LLM API                                             │
│    - 发送提示词到对应的 LLM                                  │
│    - 记录 API 延迟                                           │
│    - 处理 API 错误和重试                                     │
│    - 解析 JSON 响应                                          │
└─────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 验证决策                                                  │
│    - 验证 JSON 格式                                          │
│    - 验证必填字段                                            │
│    - 验证数值范围（leverage, confidence）                    │
│    - 检查仓位计算                                            │
└─────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 风险检查                                                  │
│    - 检查保证金充足性                                         │
│    - 检查单笔交易风险限额                                     │
│    - 检查总仓位限制                                          │
│    - 验证止损/止盈合理性                                     │
└─────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. 执行交易                                                  │
│    - 调用交易所 API                                          │
│    - 处理订单执行结果                                         │
│    - 更新数据库（trades, positions）                         │
│    - 触发 WebSocket 事件                                     │
└─────────────────────────────────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 8. 记录决策日志                                              │
│    - 保存完整的决策上下文                                     │
│    - 保存 AI 推理过程                                        │
│    - 保存执行结果                                            │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 提示词模板示例

#### 4.2.1 系统提示词
```typescript
const SYSTEM_PROMPT = `You are an autonomous AI trading agent operating on Hyperliquid perpetual futures exchange.

ROLE: Your objective is to maximize risk-adjusted returns through systematic trading of cryptocurrency derivatives.

TRADING FRAMEWORK:
- Assets: BTC, ETH, SOL, BNB, DOGE, XRP
- Leverage: 1x to 20x (select based on conviction)
- Position sizing: Calculated based on available capital, risk tolerance, and confidence
- NO pyramiding (adding to existing positions)
- NO hedging (simultaneous long/short in same asset)

MANDATORY RISK MANAGEMENT:
Every trade must include:
1. Profit Target: Specific price level to take profits
2. Stop Loss: Maximum loss threshold
3. Invalidation Condition: Market condition that invalidates your thesis
4. Confidence Score: 0.0 to 1.0 (affects position sizing)

POSITION SIZING FORMULA:
Risk Amount = Account Balance × Risk Per Trade (1-3%)
Position Size = Risk Amount / (Entry Price - Stop Loss Price)
Adjusted Size = Position Size × Confidence × Leverage

TRADING COSTS:
- Maker fee: 0.02%
- Taker fee: 0.05%
Consider fees in your profit calculations to avoid overtrading.

OUTPUT FORMAT:
You must respond with valid JSON only:
{
  "signal": "LONG" | "SHORT" | "HOLD" | "CLOSE",
  "symbol": "BTC" | "ETH" | "SOL" | "BNB" | "DOGE" | "XRP" | null,
  "quantity": <number>,
  "leverage": <1-20>,
  "confidence": <0.0-1.0>,
  "entry_reason": "<detailed reasoning>",
  "profit_target": <price>,
  "stop_loss": <price>,
  "invalidation_condition": "<specific condition>"
}

If HOLD or CLOSE, set symbol and trade-specific fields to null.`;
```

#### 4.2.2 用户提示词
```typescript
const buildUserPrompt = (marketData, accountState, performance) => {
  return `
CURRENT TIME: ${new Date().toISOString()}

MARKET DATA (OLDEST → NEWEST):
${formatMarketData(marketData)}

TECHNICAL INDICATORS:
${formatIndicators(marketData)}

ACCOUNT STATUS:
- Current Balance: $${accountState.balance.toFixed(2)}
- Available Margin: $${accountState.availableMargin.toFixed(2)}
- Open Positions: ${accountState.positions.length}
${formatPositions(accountState.positions)}

PERFORMANCE METRICS:
- Total PnL: ${performance.totalPnL >= 0 ? '+' : ''}$${performance.totalPnL.toFixed(2)} (${performance.totalPnLPct >= 0 ? '+' : ''}${performance.totalPnLPct.toFixed(2)}%)
- Sharpe Ratio: ${performance.sharpeRatio.toFixed(3)}
- Win Rate: ${performance.winRate.toFixed(1)}%
- Total Trades: ${performance.totalTrades}

INSTRUCTIONS:
Analyze the market data and your current portfolio. Make ONE of the following decisions:
1. LONG: Enter a new long position or add to existing
2. SHORT: Enter a new short position or add to existing
3. HOLD: Maintain current positions without changes
4. CLOSE: Close one or more existing positions

Remember:
- Data is ordered OLDEST → NEWEST (most recent data is at the bottom)
- Consider trading fees (0.02-0.05%) in your calculations
- Use confidence score to adjust position sizing
- Include complete risk management parameters
- Provide detailed reasoning for your decision

Respond with valid JSON only.`;
};
```

### 4.3 LLM 集成

```typescript
// src/services/tradingEngine/llmIntegration.ts

interface LLMConfig {
  provider: 'openai' | 'anthropic' | 'google' | 'xai' | 'deepseek' | 'qwen';
  modelId: string;
  apiKey: string;
  temperature?: number;
  maxTokens?: number;
}

interface TradingDecision {
  signal: 'LONG' | 'SHORT' | 'HOLD' | 'CLOSE';
  symbol?: string;
  quantity?: number;
  leverage?: number;
  confidence?: number;
  entry_reason?: string;
  profit_target?: number;
  stop_loss?: number;
  invalidation_condition?: string;
}

class LLMIntegration {
  async callLLM(
    config: LLMConfig,
    systemPrompt: string,
    userPrompt: string
  ): Promise<{ decision: TradingDecision; latency: number; rawResponse: string }> {
    const startTime = Date.now();

    try {
      let response: string;

      switch (config.provider) {
        case 'openai':
          response = await this.callOpenAI(config, systemPrompt, userPrompt);
          break;
        case 'anthropic':
          response = await this.callAnthropic(config, systemPrompt, userPrompt);
          break;
        case 'google':
          response = await this.callGoogle(config, systemPrompt, userPrompt);
          break;
        // ... other providers
        default:
          throw new Error(`Unsupported provider: ${config.provider}`);
      }

      const latency = Date.now() - startTime;
      const decision = this.parseDecision(response);

      return { decision, latency, rawResponse: response };
    } catch (error) {
      logger.error('LLM API call failed', { error, config: config.provider });
      throw error;
    }
  }

  private async callOpenAI(config: LLMConfig, systemPrompt: string, userPrompt: string): Promise<string> {
    const openai = new OpenAI({ apiKey: config.apiKey });

    const completion = await openai.chat.completions.create({
      model: config.modelId,
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      temperature: config.temperature || 0.7,
      max_tokens: config.maxTokens || 1000,
      response_format: { type: 'json_object' }
    });

    return completion.choices[0].message.content;
  }

  private parseDecision(response: string): TradingDecision {
    try {
      const json = JSON.parse(response);
      // Validate required fields
      if (!json.signal || !['LONG', 'SHORT', 'HOLD', 'CLOSE'].includes(json.signal)) {
        throw new Error('Invalid signal');
      }
      return json as TradingDecision;
    } catch (error) {
      logger.error('Failed to parse LLM response', { response, error });
      throw new Error('Invalid LLM response format');
    }
  }
}
```

### 4.4 风险管理

```typescript
// src/services/tradingEngine/riskManager.ts

class RiskManager {
  private readonly MAX_POSITION_RISK = 0.03;  // 3% per trade
  private readonly MAX_TOTAL_EXPOSURE = 0.5;   // 50% of capital
  private readonly MAX_LEVERAGE = 20;
  private readonly MIN_CONFIDENCE = 0.3;

  validateDecision(
    decision: TradingDecision,
    accountState: AccountState
  ): { valid: boolean; reason?: string } {
    // 1. Check confidence threshold
    if (decision.confidence && decision.confidence < this.MIN_CONFIDENCE) {
      return { valid: false, reason: 'Confidence too low' };
    }

    // 2. Check leverage limits
    if (decision.leverage && decision.leverage > this.MAX_LEVERAGE) {
      return { valid: false, reason: 'Leverage exceeds maximum' };
    }

    // 3. Check position sizing
    const positionValue = decision.quantity * entryPrice * decision.leverage;
    const positionRisk = positionValue / accountState.balance;

    if (positionRisk > this.MAX_POSITION_RISK) {
      return { valid: false, reason: 'Position risk too high' };
    }

    // 4. Check total exposure
    const totalExposure = this.calculateTotalExposure(accountState);
    if (totalExposure + positionRisk > this.MAX_TOTAL_EXPOSURE) {
      return { valid: false, reason: 'Total exposure limit reached' };
    }

    // 5. Check margin sufficiency
    const requiredMargin = positionValue / decision.leverage;
    if (requiredMargin > accountState.availableMargin) {
      return { valid: false, reason: 'Insufficient margin' };
    }

    // 6. Validate stop loss
    if (decision.stop_loss) {
      const stopLossDistance = Math.abs(entryPrice - decision.stop_loss) / entryPrice;
      if (stopLossDistance < 0.005 || stopLossDistance > 0.2) {
        return { valid: false, reason: 'Stop loss too tight or too wide' };
      }
    }

    return { valid: true };
  }

  calculatePositionSize(
    decision: TradingDecision,
    entryPrice: number,
    balance: number
  ): number {
    const riskAmount = balance * this.MAX_POSITION_RISK;
    const stopLossDistance = Math.abs(entryPrice - decision.stop_loss);
    const baseSize = riskAmount / stopLossDistance;

    // Adjust by confidence
    const adjustedSize = baseSize * decision.confidence;

    return adjustedSize;
  }
}
```

## 5. 前端组件设计

### 5.1 核心组件

#### 5.1.1 PriceCard 组件
```typescript
// src/components/trading/PriceCard.tsx

interface PriceCardProps {
  symbol: string;
  price: number;
  change24h: number;
  volume24h: number;
}

const PriceCard: React.FC<PriceCardProps> = ({ symbol, price, change24h, volume24h }) => {
  const isPositive = change24h >= 0;

  return (
    <div className="price-card">
      <div className="symbol">
        <img src={`/assets/icons/${symbol.toLowerCase()}.svg`} alt={symbol} />
        <span>{symbol}</span>
      </div>
      <div className="price">${price.toLocaleString()}</div>
      <div className={`change ${isPositive ? 'positive' : 'negative'}`}>
        {isPositive ? '+' : ''}{change24h.toFixed(2)}%
      </div>
      <div className="volume">Vol: ${(volume24h / 1e6).toFixed(2)}M</div>
    </div>
  );
};
```

#### 5.1.2 TradingChart 组件
```typescript
// src/components/charts/TradingChart.tsx

interface TradingChartProps {
  symbol: string;
  data: CandlestickData[];
  trades?: Trade[];
  positions?: Position[];
}

const TradingChart: React.FC<TradingChartProps> = ({ symbol, data, trades, positions }) => {
  const chartRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!chartRef.current) return;

    const chart = createChart(chartRef.current, {
      width: chartRef.current.clientWidth,
      height: 400,
      layout: {
        background: { color: '#1a1a1a' },
        textColor: '#d1d4dc',
      },
      grid: {
        vertLines: { color: '#2a2a2a' },
        horzLines: { color: '#2a2a2a' },
      },
    });

    const candlestickSeries = chart.addCandlestickSeries();
    candlestickSeries.setData(data);

    // Add markers for trades
    if (trades) {
      const markers = trades.map(trade => ({
        time: trade.entry_time,
        position: trade.side === 'LONG' ? 'belowBar' : 'aboveBar',
        color: trade.side === 'LONG' ? '#26a69a' : '#ef5350',
        shape: trade.side === 'LONG' ? 'arrowUp' : 'arrowDown',
        text: `${trade.side} @ ${trade.entry_price}`,
      }));
      candlestickSeries.setMarkers(markers);
    }

    return () => chart.remove();
  }, [data, trades]);

  return <div ref={chartRef} className="trading-chart" />;
};
```

#### 5.1.3 ModelCard 组件
```typescript
// src/components/trading/ModelCard.tsx

interface ModelCardProps {
  model: AIModel;
  performance: PerformanceMetric;
  onClick: () => void;
}

const ModelCard: React.FC<ModelCardProps> = ({ model, performance, onClick }) => {
  return (
    <div className="model-card" onClick={onClick}>
      <div className="model-header">
        <h3>{model.name}</h3>
        <span className={`status ${model.status}`}>{model.status}</span>
      </div>
      <div className="model-balance">
        ${model.current_balance.toLocaleString()}
        <span className={performance.total_pnl_pct >= 0 ? 'positive' : 'negative'}>
          {performance.total_pnl_pct >= 0 ? '+' : ''}{performance.total_pnl_pct.toFixed(2)}%
        </span>
      </div>
      <div className="model-metrics">
        <div className="metric">
          <label>Sharpe</label>
          <value>{performance.sharpe_ratio.toFixed(2)}</value>
        </div>
        <div className="metric">
          <label>Win Rate</label>
          <value>{performance.win_rate.toFixed(1)}%</value>
        </div>
        <div className="metric">
          <label>Trades</label>
          <value>{performance.total_trades}</value>
        </div>
      </div>
    </div>
  );
};
```

### 5.2 自定义 Hooks

#### 5.2.1 useWebSocket Hook
```typescript
// src/hooks/useWebSocket.ts

interface UseWebSocketReturn {
  connected: boolean;
  subscribe: (event: string, callback: (data: any) => void) => void;
  unsubscribe: (event: string) => void;
  emit: (event: string, data?: any) => void;
}

export const useWebSocket = (url: string): UseWebSocketReturn => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [connected, setConnected] = useState(false);

  useEffect(() => {
    const newSocket = io(url, {
      transports: ['websocket'],
      autoConnect: true,
    });

    newSocket.on('connect', () => {
      console.log('WebSocket connected');
      setConnected(true);
    });

    newSocket.on('disconnect', () => {
      console.log('WebSocket disconnected');
      setConnected(false);
    });

    setSocket(newSocket);

    return () => {
      newSocket.close();
    };
  }, [url]);

  const subscribe = useCallback((event: string, callback: (data: any) => void) => {
    if (socket) {
      socket.on(event, callback);
    }
  }, [socket]);

  const unsubscribe = useCallback((event: string) => {
    if (socket) {
      socket.off(event);
    }
  }, [socket]);

  const emit = useCallback((event: string, data?: any) => {
    if (socket && connected) {
      socket.emit(event, data);
    }
  }, [socket, connected]);

  return { connected, subscribe, unsubscribe, emit };
};
```

#### 5.2.2 useMarketData Hook
```typescript
// src/hooks/useMarketData.ts

export const useMarketData = (symbols: string[]) => {
  const { connected, subscribe, unsubscribe } = useWebSocket(WS_URL);
  const [prices, setPrices] = useState<Record<string, number>>({});

  useEffect(() => {
    if (!connected) return;

    const handlePriceUpdate = (data: { symbol: string; price: number }) => {
      setPrices(prev => ({
        ...prev,
        [data.symbol]: data.price,
      }));
    };

    subscribe('price:update', handlePriceUpdate);

    // Subscribe to specific symbols
    symbols.forEach(symbol => {
      emit('subscribe:price', { symbol });
    });

    return () => {
      unsubscribe('price:update');
    };
  }, [connected, symbols]);

  return prices;
};
```

## 6. 部署方案

### 6.1 Docker 配置

#### 6.1.1 前端 Dockerfile
```dockerfile
# frontend/Dockerfile

FROM node:18-alpine AS builder

WORKDIR /app

COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM nginx:alpine

COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

#### 6.1.2 后端 Dockerfile
```dockerfile
# backend/Dockerfile

FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["node", "dist/server.js"]
```

#### 6.1.3 Docker Compose
```yaml
# docker-compose.yml

version: '3.8'

services:
  mysql:
    image: mysql:8.0
    container_name: nof1-mysql
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MYSQL_DATABASE: nof1_db
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASSWORD}
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./backend/db/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - nof1-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: nof1-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - nof1-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: nof1-backend
    environment:
      NODE_ENV: production
      PORT: 3000
      DB_HOST: mysql
      DB_PORT: 3306
      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: nof1_db
      REDIS_HOST: redis
      REDIS_PORT: 6379
      JWT_SECRET: ${JWT_SECRET}
      # LLM API Keys
      OPENAI_API_KEY: ${OPENAI_API_KEY}
      ANTHROPIC_API_KEY: ${ANTHROPIC_API_KEY}
      GOOGLE_AI_API_KEY: ${GOOGLE_AI_API_KEY}
      # Exchange API
      HYPERLIQUID_API_KEY: ${HYPERLIQUID_API_KEY}
      HYPERLIQUID_SECRET: ${HYPERLIQUID_SECRET}
    ports:
      - "3000:3000"
    depends_on:
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - nof1-network
    volumes:
      - ./backend/logs:/app/logs
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: nof1-frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - nof1-network
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    container_name: nof1-nginx
    ports:
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend
    networks:
      - nof1-network
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:

networks:
  nof1-network:
    driver: bridge
```

### 6.2 环境变量配置

```bash
# .env.example

# Database
DB_ROOT_PASSWORD=your_root_password
DB_USER=nof1_user
DB_PASSWORD=your_db_password
DB_NAME=nof1_db

# JWT
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=7d

# LLM API Keys
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
GOOGLE_AI_API_KEY=...
XAI_API_KEY=...
DEEPSEEK_API_KEY=...
QWEN_API_KEY=...

# Exchange API
HYPERLIQUID_API_KEY=...
HYPERLIQUID_SECRET=...
HYPERLIQUID_TESTNET=true

# Application
NODE_ENV=production
PORT=3000
FRONTEND_URL=https://nof1.ai
CORS_ORIGIN=https://nof1.ai

# Redis
REDIS_HOST=redis
REDIS_PORT=6379

# Trading Configuration
TRADING_INTERVAL_MS=180000  # 3 minutes
MAX_LEVERAGE=20
MAX_POSITION_RISK=0.03
```

## 7. 开发计划

### 7.1 第一阶段：基础设施搭建（Week 1-2）

#### Sprint 1.1: 项目初始化
- [ ] 创建项目仓库和目录结构
- [ ] 配置 TypeScript, ESLint, Prettier
- [ ] 搭建前端开发环境（React + Vite）
- [ ] 搭建后端开发环境（Express + TypeORM）
- [ ] 配置 Docker Compose 开发环境

#### Sprint 1.2: 数据库设计
- [ ] 编写数据库迁移脚本
- [ ] 创建所有表和索引
- [ ] 定义 TypeORM 实体
- [ ] 编写数据库种子数据（测试用）

#### Sprint 1.3: 基础 API
- [ ] 实现用户认证系统（注册、登录、JWT）
- [ ] 实现用户管理 CRUD
- [ ] 实现 AI 模型管理 CRUD
- [ ] 编写 API 文档（Swagger）

### 7.2 第二阶段：市场数据系统（Week 3-4）

#### Sprint 2.1: 数据采集
- [ ] 集成市场数据源 API
- [ ] 实现实时价格采集任务
- [ ] 实现历史数据回填
- [ ] 存储到 MySQL

#### Sprint 2.2: 技术指标计算
- [ ] 实现 EMA 计算
- [ ] 实现 MACD 计算
- [ ] 实现 RSI 计算
- [ ] 实现 ATR 计算

#### Sprint 2.3: 实时推送
- [ ] 搭建 WebSocket 服务器
- [ ] 实现价格实时推送
- [ ] 前端 WebSocket 客户端
- [ ] 实时图表展示

### 7.3 第三阶段：交易引擎（Week 5-7）

#### Sprint 3.1: LLM 集成
- [ ] 实现 OpenAI 集成
- [ ] 实现 Anthropic 集成
- [ ] 实现 Google AI 集成
- [ ] 实现其他 LLM 提供商
- [ ] 提示词模板系统

#### Sprint 3.2: 交易决策循环
- [ ] 实现定时任务调度
- [ ] 构建市场数据上下文
- [ ] 调用 LLM 获取决策
- [ ] 解析和验证决策

#### Sprint 3.3: 风险管理
- [ ] 实现风险检查逻辑
- [ ] 实现仓位计算
- [ ] 实现保证金管理
- [ ] 实现止损/止盈监控

#### Sprint 3.4: 订单执行（模拟）
- [ ] 实现模拟交易执行
- [ ] 记录交易到数据库
- [ ] 更新持仓状态
- [ ] 计算盈亏

### 7.4 第四阶段：前端界面（Week 8-10）

#### Sprint 4.1: 核心页面
- [ ] 首页/仪表板
- [ ] 实时交易页面
- [ ] 排行榜页面
- [ ] 模型详情页面

#### Sprint 4.2: 图表和可视化
- [ ] 价格图表组件
- [ ] 性能曲线图
- [ ] 交易历史可视化
- [ ] 响应式设计

#### Sprint 4.3: 交互功能
- [ ] 模型切换
- [ ] 实时更新
- [ ] 筛选和排序
- [ ] 导出数据

### 7.5 第五阶段：高级功能（Week 11-12）

#### Sprint 5.1: 分析系统
- [ ] 性能指标计算
- [ ] 排行榜算法
- [ ] 模型对比功能
- [ ] 统计报表

#### Sprint 5.2: 博客系统
- [ ] 博客 CRUD API
- [ ] Markdown 编辑器
- [ ] 文章展示页面
- [ ] SEO 优化

#### Sprint 5.3: 用户功能
- [ ] 等待列表系统
- [ ] 邮件通知
- [ ] 用户偏好设置

### 7.6 第六阶段：测试与优化（Week 13-14）

#### Sprint 6.1: 测试
- [ ] 单元测试（后端）
- [ ] 集成测试
- [ ] E2E 测试（前端）
- [ ] 性能测试

#### Sprint 6.2: 优化
- [ ] 数据库查询优化
- [ ] Redis 缓存优化
- [ ] 前端性能优化
- [ ] 代码重构

#### Sprint 6.3: 部署
- [ ] 生产环境配置
- [ ] CI/CD 管道
- [ ] 监控和日志
- [ ] 备份策略

### 7.7 第七阶段：真实交易集成（Week 15+）

#### Sprint 7.1: 交易所集成
- [ ] Hyperliquid API 集成
- [ ] 订单管理
- [ ] 持仓同步
- [ ] 错误处理

#### Sprint 7.2: 安全性
- [ ] API 密钥加密
- [ ] 交易权限管理
- [ ] 风险限额控制
- [ ] 审计日志

## 8. 技术难点与解决方案

### 8.1 数据时序性
**问题**: LLM 容易混淆数据时间顺序

**解决方案**:
- 明确标注数据顺序（OLDEST → NEWEST）
- 在提示词中重复强调时间顺序
- 使用时间戳而非相对时间

### 8.2 LLM 响应不稳定
**问题**: LLM 可能返回无效 JSON 或违反规则

**解决方案**:
- 使用 JSON mode（OpenAI）或严格输出格式
- 多层验证（格式、字段、数值范围）
- 失败重试机制（最多 3 次）
- 降级策略（返回 HOLD）

### 8.3 实时性能
**问题**: 需要低延迟的数据更新和交易执行

**解决方案**:
- WebSocket 推送而非轮询
- Redis 缓存热数据
- 数据库索引优化
- 异步任务处理

### 8.4 成本控制
**问题**: LLM API 调用成本高

**解决方案**:
- 优化提示词长度
- 使用较小的模型（如 GPT-4 mini）
- 缓存市场数据
- 合理设置调用频率

### 8.5 安全性
**问题**: API 密钥、资金安全

**解决方案**:
- 加密存储 API 密钥
- 环境变量隔离
- 最小权限原则
- 资金限额控制
- 审计日志

## 9. 监控与运维

### 9.1 日志系统
```typescript
// Winston logger configuration
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.File({ filename: 'logs/trades.log', level: 'info' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple(),
  }));
}
```

### 9.2 关键指标监控
- 系统健康：CPU、内存、磁盘使用率
- API 性能：响应时间、错误率
- LLM 调用：延迟、成本、失败率
- 交易指标：执行成功率、延迟
- WebSocket：连接数、消息吞吐量

### 9.3 告警机制
- 系统异常告警
- 交易失败告警
- 性能降级告警
- 资金风险告警

## 10. 总结

本设计方案为 NOF1.AI 复刻项目提供了完整的技术蓝图，涵盖：

1. **系统架构**: 前后端分离，微服务化设计
2. **数据库设计**: 完整的 ER 模型和表结构
3. **API 设计**: RESTful + WebSocket 双通道
4. **交易引擎**: AI 决策循环、风险管理、订单执行
5. **前端组件**: React + TypeScript 现代化组件
6. **部署方案**: Docker 容器化部署
7. **开发计划**: 14 周分阶段交付

关键特性：
- 实时 AI 交易决策
- 多 LLM 并行竞技
- 完整的风险管理
- 实时数据可视化
- 可扩展架构

下一步行动：
1. 创建项目仓库
2. 初始化前后端项目
3. 搭建开发环境
4. 开始 Sprint 1.1

---

**文档版本**: 1.0
**完成日期**: 2025-10-29
